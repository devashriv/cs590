<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - drag controls</title>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - drag controls<br />
			Use "Shift+Click" to add/remove objects to/from a group.<br />
			Grouped objects can be transformed as a union.
		</div>
		<script type="text/javascript" src="js/libs/dat.gui.min.js"></script>
		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { PLYLoader } from './jsm/loaders/PLYLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { TransformControls } from './jsm/controls/TransformControls.js';
			import { BufferGeometryUtils} from './jsm/utils/BufferGeometryUtils.js';
			
			var container;
			var camera, scene, renderer;
			var frustumSize = 200;
			var controls_drag, group,control,orbit;
			var objects = [];
			var enableSelection = false;
			var click_counter=0;
			var first =0;

			var mouse = new THREE.Vector2(), raycaster = new THREE.Raycaster();
			
			var m_socket, bb_m_socket, f_socket, bb_f_socket, horn, bb_horn, servo, bb_servo, thinge, bb_thinge, bhinge, bb_bhinge,
			link1, bb_link1, link2, bb_link2;
			var mBoxHelper, fBoxHelper, hBoxHelper, sBoxHelper, thBoxHelper, bhBoxHelper, l1BoxHelper, l2BoxHelper;
			var selectedObject;
			var msload_flag = false,
			fsload_flag = false,
			sload_flag = false,
			hload_flag = false,
			thload_flag = false,
			bhload_flag = false,
			l1load_flag = false,
			l2load_flag = false;
			
			var fsl1_joint = false;
			
			//var geometry = new THREE.Geometry();
			
			group = new THREE.Group();
			//scene.add( group );

			init();
			animate();
			
			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				var aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 );
				//camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 5000 );
				camera.position.z = 200;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				scene.add( new THREE.AmbientLight( 0x505050 ) );

				var light = new THREE.SpotLight( 0xffffff, 1.5 );
				light.position.set( 0, 500, 2000 );
				light.angle = Math.PI / 9;

				light.castShadow = true;
				light.shadow.camera.near = 1000;
				light.shadow.camera.far = 4000;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				scene.add( light );

				
				
				//load_msocket();

				//load_fsocket();
				
				//load_horn();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

				/*
				//Drag Controls
				controls_drag = new DragControls( objects, camera, renderer.domElement );
				controls_drag.addEventListener( 'drag', render );
				*/
							
				//transform controls and orbit
				orbit = new OrbitControls( camera, renderer.domElement );
				orbit.update();
				orbit.addEventListener( 'change', render );

				control = new TransformControls( camera, renderer.domElement );
				control.addEventListener( 'change', render );

				control.addEventListener( 'dragging-changed', function ( event ) {

					orbit.enabled = ! event.value;

				} );

				window.addEventListener( 'resize', onWindowResize, false );

				//document.addEventListener( 'click', onClick, false );
				//window.addEventListener( 'keydown', onKeyDown, false );
				//window.addEventListener( 'keyup', onKeyUp, false );
				window.addEventListener('mousedown', onDocumentMouseDown, false);
				//render();
				displaygui();

			}
			
		
			
	function displaygui()
	{
		var gui = new dat.gui.GUI();
		var jar;
		var speed = 0.1;
		var parameters = 
		{
			loadmsocket : function(){ load_msocket(); },
			loadfsocket : function(){ load_fsocket(); },
			loadhorn : function(){ load_horn(); },
			loadservo : function(){ load_servo(); },
			loadthinge : function () {load_thinge();},
			loadbhinge : function() { load_bhinge();},
			loadlink1 : function() { load_link1();},
			loadlink2 : function(){ load_link2();}
		};
				
		gui.add(parameters, 'loadmsocket').name('Male Socket');
		gui.add(parameters, 'loadfsocket').name('Female Socket');
		gui.add(parameters, 'loadhorn').name('Horn');
		gui.add(parameters, 'loadservo').name('Servo');
		gui.add(parameters, 'loadthinge').name('Top Hinge');
		gui.add(parameters, 'loadbhinge').name('Bottom Hinge');
		gui.add(parameters, 'loadlink1').name('Link 1');
		gui.add(parameters, 'loadlink2').name('Link 2');
		
		gui.open();
	}

	function onWindowResize() 
	{
		/*
		//orthographic camera
		var aspect = window.innerWidth / window.innerHeight;

				camera.left = - frustumSize * aspect / 2;
				camera.right = frustumSize * aspect / 2;
				camera.top = frustumSize / 2;
				camera.bottom = - frustumSize / 2;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			*/	
				
		//perspective camera
		camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();
	}


	
	function onDocumentMouseDown(event) {
        event.preventDefault();
		
		
		if (event.button == 2)
		{
		
		
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y =  - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(objects, true);
		
        if (intersects.length > 0) {
            part_handles(intersects[0].object);	
        }
		}
		
		/*if (event.button == 0)
		{
			mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
			mouse.y =  - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);

			var intersects = raycaster.intersectObjects(objects, true);
			
			if (intersects.length > 0) {
				intersects[0].face.material.color.set( 0xff0000 );	
			}
		}*/
		
		/*if (event.button == 0)
		{
			mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
			mouse.y =  - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);

			var intersects = raycaster.intersectObjects(objects, true);
			//var selectedsurface = intersects[0].face;
			m_socket.lookAt(intersects[0].face.normal);
			if (intersects.length > 0) {
				
			}
			
		}*/
    }
	/*
	function load_flag(Mesh)
	{
	return true;
	}
	
	function mate_flag(Mesh)
	{
	return true;
	}
	
	function joint_flag(Mesh)
	{
	return true;
	}
	*/
	// Default click handler for our three.js objects
	function part_handles(Mesh) {
	
		if(Mesh.name == 'f_socket' && Mesh.mate_flag==true)
		{	
			//only rotation
			control.setMode("rotate");
			control.attach( Mesh );
			scene.add( control );
		}
		
		else if(Mesh.name == 'bhinge' && Mesh.mate_flag==true)
		{
			//only rotation about Z
			control.setMode("rotate");
			control.showX = false;
			control.showY = false;
			
			control.attach( Mesh );
			scene.add( control );
		}
		
		else if(Mesh.name == 'thinge' && Mesh.joint_flag==true)
		{
			//no handles
		}
		
		else if(Mesh.name == 'link1' && Mesh.joint_flag==true)
		{
			//no handles
		}
		
		else if(Mesh.name == 'link2' && Mesh.joint_flag==true)
		{
			//no handles
		}
		
		else
		{
			click_counter++;
			control.showX = true;
			control.showY = true;
			control.showZ = true;
			if (click_counter==2) click_counter =0;
			
			switch (click_counter)
			{
			
			case 0:
			control.setMode( "rotate" );
			break;
			
			case 1:
			control.setMode( "translate" );
			break;
			
			}
			
			control.attach( Mesh );
			scene.add( control );
			
		}
			
			
			
	}
	
	function animate()
	{
		requestAnimationFrame(animate);
		render();
	}

	function render() 
	{
		if (msload_flag==true && fsload_flag==true)
		{
			if(bb_m_socket.intersectsBox(bb_f_socket))
			{
				f_socket.position.y = m_socket.position.y;
				f_socket.position.x = m_socket.position.x;
				f_socket.position.z = m_socket.position.z;
				m_socket.mate_flag= true;
				f_socket.mate_flag=true;
			}
		}
		
		if(sload_flag==true && hload_flag==true)
		{
			if(bb_horn.intersectsBox(bb_servo))
			{
				horn.position.y = servo.position.y + 15;
				horn.position.x = servo.position.x -5;
				horn.position.z = servo.position.z;
			}
		}
		
			
		if (l1load_flag==true && fsload_flag==true)
		{
			if(bb_link1.intersectsBox(bb_f_socket))
			{
				/*if (link1.joint_flag==false)*/
				{
				link1.position.y = f_socket.position.y;
				link1.position.x = f_socket.position.x;
				link1.position.z = f_socket.position.z;
				link1.rotation.x = f_socket.rotation.x;
				link1.rotation.y = f_socket.rotation.y;
				link1.rotation.z = f_socket.rotation.z;
				link1.joint_flag = true;
				}
				//link1.joint_flag = true;
				f_socket.joint_flag = true;
				//f_socket.add(link1);

			}
		}
		
		if (l1load_flag==true && thload_flag==true)
		{
			if(bb_link1.intersectsBox(bb_thinge))
			{
				/*if (link1.joint_flag==false)*/
				{
				
				thinge.position.y = link1.position.y;
				thinge.position.x = link1.position.x;
				thinge.position.z = link1.position.z;
				
				thinge.rotation.x = link1.rotation.x;
				thinge.rotation.y = link1.rotation.y;
				thinge.rotation.z = link1.rotation.z;
				
				thinge.translateY(14.652+40+2.5);
				thinge.translateX(25.48);
				thinge.rotateX(Math.PI);
				thinge.rotateZ(Math.PI/2);
				

				//thinge.rotation.x = Math.PI;
				
				
				
				
				//thinge.joint_flag = true;
				}
				//link1.joint_flag = true;
				//link1.joint_flag = true;
				//f_socket.add(link1);

			}
		}
		
		if (thload_flag==true && bhload_flag==true)
		{
			if(bb_thinge.intersectsBox(bb_bhinge))
			{
				bhinge.position.y = thinge.position.y;
				bhinge.position.x = thinge.position.x;
				bhinge.position.z = thinge.position.z;
				bhinge.rotation.x = thinge.rotation.x;
				bhinge.rotation.y = thinge.rotation.y;
				//bhinge.rotation.z = thinge.rotation.z;
				bhinge.mate_flag=true;
				thinge.mate_flag=true;

			}
		}
		
		if (bhload_flag==true && l2load_flag==true)
		{
			if(bb_thinge.intersectsBox(bb_bhinge))
			{
				link2.position.x = bhinge.position.x;
				link2.position.y = bhinge.position.y;
				link2.position.z = bhinge.position.z;
				
				link2.rotation.x = bhinge.rotation.x;
				link2.rotation.y = bhinge.rotation.y;
				link2.rotation.z = bhinge.rotation.z;
				
				link2.rotateZ(Math.PI);
				link2.translateY(10);
				
				link2.joint_flag = true;
				bhinge.joint_flag = true;

			}
		}
		
		
		if (msload_flag==true)
		{
			bb_m_socket.setFromObject(m_socket);
			mBoxHelper.update();
		}
		if (fsload_flag==true)
		{
			bb_f_socket.setFromObject(f_socket);
			fBoxHelper.update();
		}
		if (hload_flag==true)
		{
			bb_horn.setFromObject(horn);
			hBoxHelper.update();
		}
		if (sload_flag==true)
		{
			bb_servo.setFromObject(servo);
			sBoxHelper.update();
		}
		if (thload_flag==true)
		{
			bb_thinge.setFromObject(thinge);
			thBoxHelper.update();
		}
		if (bhload_flag==true)
		{
			bb_bhinge.setFromObject(bhinge);
			bhBoxHelper.update();
		}
		if (l1load_flag==true)
		{
			bb_link1.setFromObject(link1);
			l1BoxHelper.update();
		}
		if (l2load_flag==true)
		{
			bb_link2.setFromObject(link2);
			l2BoxHelper.update();
		}
		
		renderer.clear();
		renderer.render( scene, camera );		

	}


function load_msocket()
		{
			var loader = new PLYLoader();
			loader.load( './models/ply/makemate/Socket Joint Male.ply', function ( geometry ) 
			{

				geometry.computeVertexNormals();
				var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
				m_socket = new THREE.Mesh( geometry, material );
				m_socket.name = "m_socket";
				bb_m_socket = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				bb_m_socket.setFromObject(m_socket);
				
				mBoxHelper = new THREE.BoxHelper(m_socket, 0x00ff00);
			
				m_socket.position.y = 20;

				m_socket.castShadow = true;
				m_socket.receiveShadow = true;
				
				m_socket.mate_flag= false;
				
				group.add(m_socket);
				scene.add(group);

				m_socket.callback = function() {part_handles(m_socket);}
				
				scene.add( m_socket );
				objects.push( m_socket );
				msload_flag= true;
			} );
		}
			
	function load_fsocket()
	{
		var loader = new PLYLoader();
		loader.load( './models/ply/makemate/Socket Joint Female.ply', function ( geometry ) 
		{
			geometry.computeVertexNormals();

			var material = new THREE.MeshStandardMaterial( { color: 0xffffff, flatShading: true } );
			f_socket = new THREE.Mesh( geometry, material );
			f_socket.name = "f_socket";		
					
					
			//f_socket.geometry.computeBoundingBox();
			//bb_f_socket = new THREE.Box3(  f_socket.geometry.boundingBox.min, f_socket.geometry.boundingBox.max);			
			fBoxHelper = new THREE.BoxHelper(f_socket, 0x00ff00);
			scene.add(fBoxHelper);
			
			//f_socket.position.x = - 5;
			f_socket.position.y = - 40;
			//f_socket.position.z = - 5;
			//f_socket.rotation.z=  Math.PI;
			//f_socket.scale.multiplyScalar( 3 );
			
			f_socket.updateMatrix();
			bb_f_socket = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
			bb_f_socket.setFromObject(f_socket);
			fBoxHelper.update();
			
			f_socket.mate_flag= false;
			
			f_socket.castShadow = true;
			f_socket.receiveShadow = true;

			f_socket.callback = function() {part_handles(f_socket);};
			
			//group.add(f_socket);
			//scene.add(group);
			scene.add( f_socket );
			objects.push( f_socket );
			fsload_flag= true;
		} );
	}
			
	function load_horn()
	{
		var loader = new PLYLoader();
		loader.load( './models/ply/makemate/horn.ply', function ( geometry ) 
		{
			geometry.computeVertexNormals();
			var material = new THREE.MeshStandardMaterial( { color: 0xffffff, flatShading: true } );
			horn = new THREE.Mesh( geometry, material );
			//horn.geometry.computeBoundingBox();
			//bb_horn = new THREE.Box3(  horn.geometry.boundingBox.min, horn.geometry.boundingBox.max);
			hBoxHelper = new THREE.BoxHelper(horn, 0x00ff00);
			scene.add(hBoxHelper);
					
			horn.position.x = - 20;
			horn.position.y = - 40;
			//horn.position.z = - 5;
			horn.rotation.z=  Math.PI;
			//horn.scale.multiplyScalar( 3 );
			bb_horn = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
			bb_horn.setFromObject(horn);
			hBoxHelper.update();

			horn.castShadow = true;
			horn.receiveShadow = true;

			horn.callback = function (){part_handles(horn);}
			
			scene.add( horn );
			objects.push( horn );
			hload_flag= true;
		} );
	}
			
	function load_servo()
	{
		var loader = new PLYLoader();
		loader.load( './models/ply/makemate/servo.ply', function ( geometry ) 
		{
			geometry.computeVertexNormals();
			var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
			servo = new THREE.Mesh( geometry, material );
			//servo.geometry.computeBoundingBox();
			//bb_servo = new THREE.Box3(  servo.geometry.boundingBox.min, servo.geometry.boundingBox.max);
					
			sBoxHelper = new THREE.BoxHelper(servo, 0x00ff00);
			scene.add(sBoxHelper);
			servo.position.x = - 20;
			//servo.position.y =  40;
			//servo.position.z = - 5;
			//servo.rotation.z=  Math.PI;
			//servo.scale.multiplyScalar( 3 );
			bb_servo = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
			bb_servo.setFromObject(servo);
			sBoxHelper.update();
			servo.castShadow = true;
			servo.receiveShadow = true;
			
			servo.callback = function (){part_handles(servo);}
			
			scene.add( servo );
			objects.push( servo );
			sload_flag= true;
		} );
	}
	
	function load_thinge()
		{
			var loader = new PLYLoader();
			loader.load( './models/ply/makemate/Top Hinge Joint.ply', function ( geometry ) 
			{

				geometry.computeVertexNormals();
				var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
				thinge = new THREE.Mesh( geometry, material );
				thinge.name = "thinge";
				bb_thinge = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				bb_thinge.setFromObject(thinge);
				
				thBoxHelper = new THREE.BoxHelper(thinge, 0x00ff00);
			
				thinge.position.y = 20;
				
				thinge.mate_flag = false;
				thinge.joint_flag = false;

				thinge.castShadow = true;
				thinge.receiveShadow = true;

				thinge.callback = function() {part_handles(thinge);}
				
				scene.add( thinge );
				objects.push( thinge );
				thload_flag= true;
			} );
		}
		
		function load_bhinge()
		{
			var loader = new PLYLoader();
			loader.load( './models/ply/makemate/Bottom Hinge Joint.ply', function ( geometry ) 
			{

				geometry.computeVertexNormals();
				var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
				bhinge = new THREE.Mesh( geometry, material );
				bhinge.name = "bhinge";
				bb_bhinge = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				bb_bhinge.setFromObject(bhinge);
				
				bhBoxHelper = new THREE.BoxHelper(bhinge, 0x00ff00);
			
				bhinge.position.y = 20;
				
				bhinge.mate_flag = false;
				bhinge.joint_flag = false;

				bhinge.castShadow = true;
				bhinge.receiveShadow = true;

				bhinge.callback = function() {part_handles(bhinge);}
				
				scene.add( bhinge );
				objects.push( bhinge );
				bhload_flag= true;
			} );
		}
		
		function load_link1()
		{
			var loader = new PLYLoader();
			loader.load( './models/ply/makemate/link1.ply', function ( geometry ) 
			{

				geometry.computeVertexNormals();
				var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
				link1 = new THREE.Mesh( geometry, material );
				link1.name = "link1";
				bb_link1 = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				bb_link1.setFromObject(link1);
				
				l1BoxHelper = new THREE.BoxHelper(link1, 0x00ff00);
				
				link1.joint_flag=false;
				
				link1.position.y = 20;
				link1.updateMatrix();
				link1.castShadow = true;
				link1.receiveShadow = true;

				link1.callback = function() {part_handles(link1);}
				
				scene.add( link1 );
				objects.push( link1 );
				l1load_flag= true;
			} );
		}
		
		function load_link2()
		{
			var loader = new PLYLoader();
			loader.load( './models/ply/makemate/link2.ply', function ( geometry ) 
			{

				geometry.computeVertexNormals();
				var material = new THREE.MeshStandardMaterial( { color: 0x0055ff, flatShading: true } );
				link2 = new THREE.Mesh( geometry, material );
				link2.name = "link2";
				bb_link2 = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
				bb_link2.setFromObject(link2);
				
				l2BoxHelper = new THREE.BoxHelper(link2, 0x00ff00);
			
				link2.position.y = 20;
				
				link2.joint_flag=false;

				link2.castShadow = true;
				link2.receiveShadow = true;

				link2.callback = function() {part_handles(link2);}
				
				scene.add( link2 );
				objects.push( link2 );
				l2load_flag= true;
			} );
		}
		
		</script>

	</body>
</html>
